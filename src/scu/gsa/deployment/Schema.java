package scu.gsa.deployment;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;

import scu.gsa.deployment.ClassFinder;

import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;


public class Schema {
	private static String frameworkVersion = "0.1";
	private Path p = Paths.get("bundles");
	private String deployFile = "deploy.schema.auto.xml";
	private static Properties properties = new Properties();
	private static Integer configCounter = 0;
	
	public String getDeployFileName() {
		return deployFile;
	}

	public void setDeployFileName(String name) {
		this.deployFile = name;
	}
	
	public String getVersion() {
		return frameworkVersion;
	}

	public void setVersion(String ver) {
		Schema.frameworkVersion = ver;
	}
	
	public static void setProperties(String file) {
		try {
			properties.load(new FileInputStream(file));
		} catch (IOException e) {
			System.err.println(e);
		}
	}
	
	public Properties getProperties() {
		return properties;
	}
  
	
//	public List<xsltBundle> getXsltBundle() {
//		  return this.xbList;
//	}
	
	public static boolean StableCodes(String code)
	{
	    String[] codes = {"release", "trunk"};  
	    return (Arrays.asList(codes).contains(code));
	}
  
  public void writeSchema(String version, String deployFile) throws IOException, IllegalArgumentException {
	  
	  String envBranchName = (System.getenv("bamboo_planRepository_1_branchName") != null) ? System.getenv("bamboo_planRepository_1_branchName") : "SDA";
	  String lifecycle = (StableCodes(envBranchName)) ? "stable" : "beta";
	  
	  System.out.println("Attempting to Write Deployment Schema from /bundles/apps");
	  try {

 		  XMLOutputFactory xmlOutputFactory = XMLOutputFactory.newInstance();	
 		  final XMLStreamWriter xmlStreamWriter = xmlOutputFactory.createXMLStreamWriter(new FileOutputStream(deployFile), "UTF-8");
 		  
 		  System.out.println("Writing Document Start");
 		  
 		  xmlStreamWriter.writeStartDocument();
 		  xmlStreamWriter.writeStartElement("deployment");
 		  xmlStreamWriter.writeAttribute("project", "GSA");
 		  xmlStreamWriter.writeAttribute("version", version);
 		  xmlStreamWriter.writeAttribute("lifecycle", lifecycle);
 		  xmlStreamWriter.writeComment("\r\n\r\nAUTO GENERATED BY src.scu.gsa.deployment.Schema.writeSchema\r\n"
 		  								+ "collections - these are namespaces referenced by reports\r\n"
 				  						+ "frontends - follows native naming convention of name matches the filename of the XSLT proxysheet\r\n"
 		  								+ "tasks - used to reference tasks which implement the deployment task interface in the SCU API Stack\r\n\r\n");
 		 
 	  	    
 		 FileVisitor<Path> fv = new SimpleFileVisitor<Path>() {
 	  	      @Override
 	  	      public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
 	  	          throws IOException {
 	  	        		System.out.println(file);
 	  	        		
 		  	  	        String fileName = file.getFileName().toString();
 		  	  	        String fileFolder = file.getParent().getFileName().toString();

		  	  	        try {
		  	  	        			  	  	        	
	 			  	  	    switch (fileFolder) {
	 		  	    	  	case "resources":
	 		  	    	  			String appName = file.getParent().getParent().getFileName().toString();
	 		  	    	  			System.out.println("Writing resource node to schema for " + appName);
		 		  	    	  		xmlStreamWriter.writeStartElement("resource");
		 		  	    	  	    xmlStreamWriter.writeAttribute("appRef", appName);
		 		  	    	  	    xmlStreamWriter.writeAttribute("source", file.getParent().toString());
		 		  	    	  		xmlStreamWriter.writeEndElement();
		 		  	    	break;
	 		  	    	  	case "collections":
	 		  	    	  	//so appName is always going to be two parents up being at a folder base
	 		  	    	  			appName = file.getParent().getParent().getFileName().toString();
	 		  	    	  			System.out.println("Writing collection ref data node to schema for " + appName);
		 		  	    	  		xmlStreamWriter.writeStartElement(fileFolder.replaceAll("s$", ""));
		 		  	    	  		xmlStreamWriter.writeAttribute("name", fileName.replaceAll(".xslt$",  ""));
		 		  	    	  		xmlStreamWriter.writeAttribute("appRef", appName);
		 		  	    	  		xmlStreamWriter.writeEndElement();
	 		  	    	  		break;
	 		  	    	  	case "frontends":
	 		  	    	  			if (!fileName.contains(".properties")) {
		 		  	    	  			Properties sortOrder = new Properties();
//		 		  	    	  			try {
		 		  	    	  				sortOrder.load(new FileInputStream(file.getParent().toString() + "/sort.properties"));
		 		  	    	  				String sortNumber = sortOrder.getProperty(fileName);
		 		  	    	  				//has a sort number being set (critical)
		 		  	    	  				if (sortNumber != null && !sortNumber.isEmpty()) {
		 		  	    	  				//these are structured as bundles/apps/appName/collections|frontends
		 		 		  	    	  			//so appName is always going to be two parents up being at a folder base
		 		  	    	  				    appName = file.getParent().getParent().getFileName().toString();
		 		 		  	    	  			System.out.println("Writing app ref data node to schema for" + appName);
		 			 		  	    	  		xmlStreamWriter.writeStartElement(fileFolder.replaceAll("s$", ""));
		 			 		  	    	  		xmlStreamWriter.writeAttribute("name", fileName.replaceAll(".xslt$",  ""));
		 			 		  	    	  		xmlStreamWriter.writeAttribute("appRef", appName);
		 			 		  	    	  		xmlStreamWriter.writeAttribute("sort", sortNumber);
		 			 		  	    	  		xmlStreamWriter.writeEndElement();
		 		  	    	  				} else {
		 		  	    	  					throw new IllegalArgumentException("No config properties file entry found for " + fileName + ", this is required for a front end deployment");
		 		  	    	  				}
//		 		  	    	  			} catch (IOException e) {
//				 		  	 				System.err.println(e);
//				 		  	 			}	
	 		  	    	  			}
 		  	    	  		break;
	 		  	    	  	case "config":
	 		  	    	  		//config must be txt files
	 		  	    	  		if (fileName.contains(".txt")) {
	 		  	    	  			
			 		  	    	  	Properties keyphraseProps = new Properties();
//			 		  	 			try {
			 		  	 				keyphraseProps.load(new FileInputStream(file.toString()));
			 		  	 				String configFile = keyphraseProps.getProperty("file");
			 		  	 				String targetConfig = System.getenv("target.config");
			 		  	 				//are both strings set and equal
			 		  	 				if ((configFile != null && targetConfig != null) && configFile.equals(targetConfig)) {
			 		  	 					configCounter++;
				 		  	 				xmlStreamWriter.writeStartElement(fileFolder);
				 		  	    	  		xmlStreamWriter.writeAttribute("path", file.toString().replace(fileName, configFile));
				 		  	    	  		xmlStreamWriter.writeAttribute("key", keyphraseProps.getProperty("text"));
				 		  	    	  		xmlStreamWriter.writeEndElement();
			 		  	 				} 
//			 		  	 			} catch (IOException e) {
//			 		  	 				System.err.println(e);
//			 		  	 			}			 		  	 			
		 		  	    	  				 		  	    	  		
//		 		  	    	  		xmlStreamWriter.writeAttribute("key", appName);
		 		  	    	  		
	 		  	    	  		}

	 		  	    	  		break;
	 			  	  	    }
		  	  	        } catch (XMLStreamException e) {
		  	    	  		e.printStackTrace();
		  	    	  		System.exit(1);
		  	    	  	} 
//		  	  	     
// 	  	        System.out.println(fileName);
// 	  	        System.out.println(fileFolder);
		  	  	
 	  	        return FileVisitResult.CONTINUE;
 	  	      }
 	  	    };
  	    	System.out.println("Parsing GSA Bundles:");
  	    	try {
		      Files.walkFileTree(p, fv);
		    } catch (IOException e) {
		      e.printStackTrace();
		    }	
 	  	    if (configCounter > 0) {
 	  	    	List<Class<?>> classes = ClassFinder.find("scu.gsa.deployment");
 	  	    	if (classes != null && classes.size() > 0) {
 	  	    		xmlStreamWriter.writeStartElement("tasks");
 	  	    		System.out.println("CHECKING Method relevancy for deploy config schema");
 	  	    		for (Class<?> cl : classes) {
 		  	 			 if (cl.getInterfaces().length > 0) {
 		  	 				String taskName = cl.getSimpleName();
 		  	 				 if (cl.getInterfaces()[0].getSimpleName().contains("DeploymentTask") && !taskName.equals("Main")) {
 		  	 					 System.out.println("Relevant method '" + cl.getSimpleName() + "' found.");
 		  	 					xmlStreamWriter.writeStartElement("task");
 		  	 					xmlStreamWriter.writeAttribute("name",  taskName);
 		  	 					xmlStreamWriter.writeEndElement();
 		  	 				 }
 		  	 				
 		  	 			 }
 		  	 			
 		  	 		 }
 	  	    		xmlStreamWriter.writeEndElement();
 	  	    	} 
 		  	 		 
 	 		  
 	  	    	System.out.println("Deploy schema generation finished...");
 	  	    	
 	  	    	xmlStreamWriter.writeEndElement();
 	  	    	xmlStreamWriter.writeEndDocument();
 	  	    	xmlStreamWriter.flush();
 	  	    	xmlStreamWriter.close();
 	  	    } else {
 	  	    	throw new IllegalArgumentException("No config files matching " + System.getenv("target.config") + " please check config files exist and variable has been set.");
 	  	    }
  	    	
	  	    	 	  	    	
 	} catch (XMLStreamException e) {
 		e.printStackTrace();
 	} catch (IOException e) {
 		e.printStackTrace();
 	}
  }

  public static void main(String[] args) {
//	  List<AppSchematic> schemaList = new ArrayList<>();
	  setProperties("config.properties");
	  Schema schema = new Schema();
	  String version = (System.getenv("framework.version") != null && !System.getenv("framework.version").isEmpty()) ? System.getenv("framework.version") : frameworkVersion;
	  String deployFile = (args.length > 0) ? args[0] : schema.getDeployFileName();
	  try {
		schema.writeSchema(version, deployFile);
	} catch (Exception e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
		System.exit(1);
	}
	  

  }

}